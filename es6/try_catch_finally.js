//try 블록의 코드가 HTTP 연결이나 파일 같은 일종의 '자원'을 처리할 때가 있습니다. 프로그램에서 이 자원을 계속
//가지고 있을 수는 없으므로 에러가 있든 없든 어느 시점에서는 이 자원을 해제해야 합니다. try 블록에는 문을 원하느 만큼 쓸 수 있고,
//그중 어디서든 에러가 이렁나서 자원을 해제할 기회가 아예 사라질 수도 있으므로 try 블록에서 자원을 해제하는 건 안전하지 않습니다.
//에러가 일어나지 않으면 실행되지 않는 catch 블록 역시 안전하지 않습니다. 이런 상황에서 finally 블록이 필요합니다.
//finally 블록은 에러가 일어나든, 일어나지 않든 반드시 호출됩니다.

try{
    console.log('this line is executed...');
    //throw new Error('whoops');
    console.log('this line is not...');
}catch (e) {
    console.log('there was an error..');
}finally { // 항상 실행 됨.
    console.log('...always executed');
    console.log('perform cleanup here');
}

//예외를 어떻게 처리해야 할지 모르는 상황이 닥쳤을 때는 '포기'하는 간편한 방법이긴 하다.
//하지만 예외처리에는 비용이 필요하다. 예외를 캐치하지 못하는 위험도(프로그램 정지 등) 있고,
//예외 처리 자체도 대가를 지불해야 하는 연산입니다. 예외는 catch 블록을 만날 때까지 스택을 거슬러
// 올라가야 하므로 자바스크립트 인터프리터가 예외를 계속 추적하고 있어야 합니다.
// 컴퓨터는 점점 더 빨라지고 있으니 이런 비용은 큰 문제가 되지 않을 수도 있지만, 자주 실행되는
// 코드에서는 예외를 발생시키면 성능 문제가 발생할 가능성이 높다.
// 프로그램을 일부러 멈추려 하는게 아니라면, 예외를 일으켰으면 반드시 캐치해야 합니다.
// 원인 없는 결과는 없는 법입니다. 예외 처리는 예상할 수 없는 상황에 대비한 마지노선으로 생각하고,
// 예상할 수 있는 에러는 조건문으로 처리하는것이 최선입니다.



